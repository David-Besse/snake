import Swal from "sweetalert2";

const game = {
  snake: document.getElementById("snake"),
  snakeSegments: [],
  snakePosition: { x: 0, y: 0 },
  snakeDirection: "right",
  gridSize: 50,
  gameInterval: null,
  isPaused: false,
  colorCells: [],
  snakeLength: 4,
  lastTime: 0,
  snakeSpeed: 200,
  isGameOver: false,
  colorGenerationInterval: null, // Ajoutez une variable pour l'intervalle de génération des points de couleur
};

function createColorCell() {
  let x, y;
  do {
    x = Math.floor(Math.random() * game.gridSize);
    y = Math.floor(Math.random() * game.gridSize);
  } while (
    game.snakeSegments.some(
      (segment) =>
        segment.style.left === `${x * 10}px` &&
        segment.style.top === `${y * 10}px`
    )
  );
  const color = getRandomColor();
  const id = `color-cell-${Date.now()}-${Math.random()}`;
  return { x, y, color, id };
}

function getRandomColor() {
  let color;
  do {
    color = `#${Math.floor(Math.random() * 0xffffff)
      .toString(16)
      .padStart(6, "0")}`;
  } while (
    /^#([0-9A-F]{2}){3}$/i.test(color) &&
    parseInt(color.slice(1, 3), 16) < 100 &&
    parseInt(color.slice(3, 5), 16) < 100 &&
    parseInt(color.slice(5, 7), 16) < 100
  );
  return color;
}

function displayColorCells() {
  const grid = document.querySelector(".grid");
  const fragment = document.createDocumentFragment();

  game.colorCells.forEach((cell) => {
    if (!document.getElementById(cell.id)) {
      const cellElement = document.createElement("div");
      cellElement.classList.add("color-cell");
      cellElement.id = cell.id;
      cellElement.style.left = `${cell.x * 10}px`;
      cellElement.style.top = `${cell.y * 10}px`;
      cellElement.style.backgroundColor = cell.color;
      fragment.appendChild(cellElement);
    }
  });

  grid.appendChild(fragment);
}

function checkWallCollision() {
  const { x, y } = game.snakePosition;
  return x < 0 || x >= game.gridSize * 10 || y < 0 || y >= game.gridSize * 10;
}

function moveSnake() {
  for (let i = game.snakeSegments.length - 1; i > 0; i--) {
    game.snakeSegments[i].style.left = game.snakeSegments[i - 1].style.left;
    game.snakeSegments[i].style.top = game.snakeSegments[i - 1].style.top;
  }

  switch (game.snakeDirection) {
    case "right":
      game.snakePosition.x += 10;
      break;
    case "left":
      game.snakePosition.x -= 10;
      break;
    case "up":
      game.snakePosition.y -= 10;
      break;
    case "down":
      game.snakePosition.y += 10;
      break;
  }

  const headX = game.snakePosition.x;
  const headY = game.snakePosition.y;

  game.colorCells.forEach((cell, index) => {
    if (headX === cell.x * 10 && headY === cell.y * 10) {
      game.colorCells.splice(index, 1);

      const cellElement = document.getElementById(cell.id);

      if (cellElement) {
        console.log("Removing color cell:", cellElement.id);
        cellElement.remove();
      } else {
        console.log("Color cell not found:", cell.id);
      }

      game.snakeLength++;
      growSnake();

      if (game.snakeSpeed > 50) game.snakeSpeed -= 10;
    }
  });

  if (checkWallCollision()) {
    clearInterval(game.gameInterval);
    clearInterval(game.colorGenerationInterval); // Arrêtez l'intervalle de génération des points de couleur en cas de game over
    gameOver();
    return;
  }

  game.snakeSegments[0].style.left = game.snakePosition.x + "px";
  game.snakeSegments[0].style.top = game.snakePosition.y + "px";
}

function growSnake() {
  const tail = game.snakeSegments[game.snakeSegments.length - 1];
  const newSegment = document.createElement("div");
  newSegment.classList.add("snake-segment");
  newSegment.style.left = tail.style.left;
  newSegment.style.top = tail.style.top;
  game.snake.appendChild(newSegment);
  game.snakeSegments.push(newSegment);
}

function gameOver() {
  game.isGameOver = true;

  Swal.fire({
    title: "Game Over !",
    text: "Vous avez heurté un mur.",
    icon: "error",
    confirmButtonText: "Réessayer",
  }).then((result) => {
    if (result.isConfirmed) resetGame();
  });
}

function resetGame() {
  Object.assign(game, {
    snakePosition: { x: 0, y: 0 },
    snakeDirection: "right",
    snakeSegments: [],
    isGameOver: false,
  });

  game.snake.innerHTML = "";
  createSnake();
  clearInterval(game.gameInterval);
  clearInterval(game.colorGenerationInterval); // Arrêtez l'intervalle de génération des points de couleur
  game.gameInterval = setInterval(moveSnake, 200);
  game.colorGenerationInterval = setInterval(generateColorCell, 5000); // Redémarrez l'intervalle de génération des points de couleur
}

function createSnake() {
  game.snakeSegments = [];

  const centerX = Math.floor(game.gridSize / 2);
  const centerY = Math.floor(game.gridSize / 2);

  game.snakePosition = { x: centerX * 10, y: centerY * 10 };

  for (let i = 0; i < 4; i++) {
    const segment = document.createElement("div");
    segment.classList.add("snake-segment");
    segment.style.left = game.snakePosition.x + i * 10 + "px";
    segment.style.top = game.snakePosition.y + "px";
    game.snake.appendChild(segment);
    game.snakeSegments.push(segment);
  }
}

function gameLoop(timestamp) {
  if (game.isPaused || game.isGameOver) return;

  const delta = timestamp - game.lastTime;
  if (delta > game.snakeSpeed) {
    moveSnake();
    game.lastTime = timestamp;
  }
  requestAnimationFrame(gameLoop);
}

function generateColorCell() {
  if (game.colorCells.length >= 10) {
    const cellToRemove = document.querySelector(".grid").querySelector(".color-cell");
    if (cellToRemove) {
      cellToRemove.remove();
      game.colorCells.shift();
    }
  }

  const newColorCell = createColorCell();
  game.colorCells.push(newColorCell);
  displayColorCells();
}

document.addEventListener("DOMContentLoaded", () => {
  createSnake();
  gameLoop(0);
  game.colorGenerationInterval = setInterval(generateColorCell, 5000);
});

document.addEventListener("keydown", (event) => {
  if (event.code === "Space") {
    game.isPaused = !game.isPaused;

    document.getElementById("pause-alert").style.display = game.isPaused ? "block" : "none";
    document.getElementById("overlay").style.display = game.isPaused ? "block" : "none";

    clearInterval(game.gameInterval);
    clearInterval(game.colorGenerationInterval); // Arrêtez l'intervalle de génération des points de couleur en pause

    if (!game.isPaused) {
      gameLoop(0);
      game.colorGenerationInterval = setInterval(generateColorCell, 5000); // Reprenez l'intervalle de génération des points de couleur
    }
  } else {
    const directions = {
      ArrowUp: "up",
      ArrowDown: "down",
      ArrowLeft: "left",
      ArrowRight: "right",
    };
    if (directions[event.key]) game.snakeDirection = directions[event.key];
  }
});
